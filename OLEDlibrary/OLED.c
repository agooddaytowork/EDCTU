/*
 * OLED.c
 *
 *  Created on: Jul 4, 2015
 *      Author: Dinh
 */

/*
 * This is the library ported from Arduino's MicroLCD library
 * with some extra features added by me (including print and printwrap)
 */

#include "OLED.h"

uint8_t m_col;
uint8_t m_row;
uint8_t OLEDbroken = 0;

/*
 * These fonts are from the MicroLCD library
 */
const unsigned char digits8x8[][8] =
{
{ 0x3C, 0x7E, 0x83, 0x81, 0x81, 0x7E, 0x3C, 0x00 },/*0*/
{ 0x84, 0x84, 0x82, 0xFF, 0xFF, 0x80, 0x80, 0x00 },/*1*/
{ 0x84, 0xC6, 0xE1, 0xA1, 0xB1, 0x9F, 0x8E, 0x00 },/*2*/
{ 0x42, 0xC3, 0x81, 0x89, 0x89, 0xFF, 0x76, 0x00 },/*3*/
{ 0x20, 0x38, 0x24, 0x22, 0xFF, 0xFF, 0x20, 0x00 },/*4*/
{ 0x5F, 0xDF, 0x99, 0x89, 0x89, 0xF9, 0x70, 0x00 },/*5*/
{ 0x3C, 0x7E, 0x89, 0x89, 0x89, 0xFB, 0x72, 0x00 },/*6*/
{ 0x01, 0x01, 0xE1, 0xF9, 0x1D, 0x07, 0x01, 0x00 },/*7*/
{ 0x6E, 0xFF, 0x89, 0x89, 0x99, 0xFF, 0x76, 0x00 },/*8*/
{ 0x4E, 0xDF, 0x91, 0x91, 0x91, 0x7F, 0x3E, 0x00 }, /*9*/
};

// The 7-bit ASCII character set...
const unsigned char font5x8[][5] =
{
{ 0x00, 0x00, 0x5f, 0x00, 0x00 },  // 21 !
		{ 0x00, 0x07, 0x00, 0x07, 0x00 },  // 22 "
		{ 0x14, 0x7f, 0x14, 0x7f, 0x14 },  // 23 #
		{ 0x24, 0x2a, 0x7f, 0x2a, 0x12 },  // 24 $
		{ 0x23, 0x13, 0x08, 0x64, 0x62 },  // 25 %
		{ 0x36, 0x49, 0x55, 0x22, 0x50 },  // 26 &
		{ 0x00, 0x05, 0x03, 0x00, 0x00 },  // 27 '
		{ 0x00, 0x1c, 0x22, 0x41, 0x00 },  // 28 (
		{ 0x00, 0x41, 0x22, 0x1c, 0x00 },  // 29 )
		{ 0x14, 0x08, 0x3e, 0x08, 0x14 },  // 2a *
		{ 0x08, 0x08, 0x3e, 0x08, 0x08 },  // 2b +
		{ 0x00, 0x50, 0x30, 0x00, 0x00 },  // 2c ,
		{ 0x08, 0x08, 0x08, 0x08, 0x08 },  // 2d -
		{ 0x00, 0x60, 0x60, 0x00, 0x00 },  // 2e .
		{ 0x20, 0x10, 0x08, 0x04, 0x02 },  // 2f /
		{ 0x3e, 0x51, 0x49, 0x45, 0x3e },  // 30 0
		{ 0x00, 0x42, 0x7f, 0x40, 0x00 },  // 31 1
		{ 0x42, 0x61, 0x51, 0x49, 0x46 },  // 32 2
		{ 0x21, 0x41, 0x45, 0x4b, 0x31 },  // 33 3
		{ 0x18, 0x14, 0x12, 0x7f, 0x10 },  // 34 4
		{ 0x27, 0x45, 0x45, 0x45, 0x39 },  // 35 5
		{ 0x3c, 0x4a, 0x49, 0x49, 0x30 },  // 36 6
		{ 0x01, 0x71, 0x09, 0x05, 0x03 },  // 37 7
		{ 0x36, 0x49, 0x49, 0x49, 0x36 },  // 38 8
		{ 0x06, 0x49, 0x49, 0x29, 0x1e },  // 39 9
		{ 0x00, 0x36, 0x36, 0x00, 0x00 },  // 3a :
		{ 0x00, 0x56, 0x36, 0x00, 0x00 },  // 3b ;
		{ 0x08, 0x14, 0x22, 0x41, 0x00 },  // 3c <
		{ 0x14, 0x14, 0x14, 0x14, 0x14 },  // 3d =
		{ 0x00, 0x41, 0x22, 0x14, 0x08 },  // 3e >
		{ 0x02, 0x01, 0x51, 0x09, 0x06 },  // 3f ?
		{ 0x32, 0x49, 0x79, 0x41, 0x3e },  // 40 @
		{ 0x7e, 0x11, 0x11, 0x11, 0x7e },  // 41 A
		{ 0x7f, 0x49, 0x49, 0x49, 0x36 },  // 42 B
		{ 0x3e, 0x41, 0x41, 0x41, 0x22 },  // 43 C
		{ 0x7f, 0x41, 0x41, 0x22, 0x1c },  // 44 D
		{ 0x7f, 0x49, 0x49, 0x49, 0x41 },  // 45 E
		{ 0x7f, 0x09, 0x09, 0x09, 0x01 },  // 46 F
		{ 0x3e, 0x41, 0x49, 0x49, 0x7a },  // 47 G
		{ 0x7f, 0x08, 0x08, 0x08, 0x7f },  // 48 H
		{ 0x00, 0x41, 0x7f, 0x41, 0x00 },  // 49 I
		{ 0x20, 0x40, 0x41, 0x3f, 0x01 },  // 4a J
		{ 0x7f, 0x08, 0x14, 0x22, 0x41 },  // 4b K
		{ 0x7f, 0x40, 0x40, 0x40, 0x40 },  // 4c L
		{ 0x7f, 0x02, 0x0c, 0x02, 0x7f },  // 4d M
		{ 0x7f, 0x04, 0x08, 0x10, 0x7f },  // 4e N
		{ 0x3e, 0x41, 0x41, 0x41, 0x3e },  // 4f O
		{ 0x7f, 0x09, 0x09, 0x09, 0x06 },  // 50 P
		{ 0x3e, 0x41, 0x51, 0x21, 0x5e },  // 51 Q
		{ 0x7f, 0x09, 0x19, 0x29, 0x46 },  // 52 R
		{ 0x46, 0x49, 0x49, 0x49, 0x31 },  // 53 S
		{ 0x01, 0x01, 0x7f, 0x01, 0x01 },  // 54 T
		{ 0x3f, 0x40, 0x40, 0x40, 0x3f },  // 55 U
		{ 0x1f, 0x20, 0x40, 0x20, 0x1f },  // 56 V
		{ 0x3f, 0x40, 0x38, 0x40, 0x3f },  // 57 W
		{ 0x63, 0x14, 0x08, 0x14, 0x63 },  // 58 X
		{ 0x07, 0x08, 0x70, 0x08, 0x07 },  // 59 Y
		{ 0x61, 0x51, 0x49, 0x45, 0x43 },  // 5a Z
		{ 0x00, 0x7f, 0x41, 0x41, 0x00 },  // 5b [
		{ 0x02, 0x04, 0x08, 0x10, 0x20 },  // 5c backslash
		{ 0x00, 0x41, 0x41, 0x7f, 0x00 },  // 5d ]
		{ 0x04, 0x02, 0x01, 0x02, 0x04 },  // 5e ^
		{ 0x40, 0x40, 0x40, 0x40, 0x40 },  // 5f _
		{ 0x00, 0x01, 0x02, 0x04, 0x00 },  // 60 `
		{ 0x20, 0x54, 0x54, 0x54, 0x78 },  // 61 a
		{ 0x7f, 0x48, 0x44, 0x44, 0x38 },  // 62 b
		{ 0x38, 0x44, 0x44, 0x44, 0x20 },  // 63 c
		{ 0x38, 0x44, 0x44, 0x48, 0x7f },  // 64 d
		{ 0x38, 0x54, 0x54, 0x54, 0x18 },  // 65 e
		{ 0x08, 0x7e, 0x09, 0x01, 0x02 },  // 66 f
		{ 0x0c, 0x52, 0x52, 0x52, 0x3e },  // 67 g
		{ 0x7f, 0x08, 0x04, 0x04, 0x78 },  // 68 h
		{ 0x00, 0x44, 0x7d, 0x40, 0x00 },  // 69 i
		{ 0x20, 0x40, 0x44, 0x3d, 0x00 },  // 6a j
		{ 0x7f, 0x10, 0x28, 0x44, 0x00 },  // 6b k
		{ 0x00, 0x41, 0x7f, 0x40, 0x00 },  // 6c l
		{ 0x7c, 0x04, 0x18, 0x04, 0x78 },  // 6d m
		{ 0x7c, 0x08, 0x04, 0x04, 0x78 },  // 6e n
		{ 0x38, 0x44, 0x44, 0x44, 0x38 },  // 6f o
		{ 0x7c, 0x14, 0x14, 0x14, 0x08 },  // 70 p
		{ 0x08, 0x14, 0x14, 0x18, 0x7c },  // 71 q
		{ 0x7c, 0x08, 0x04, 0x04, 0x08 },  // 72 r
		{ 0x48, 0x54, 0x54, 0x54, 0x20 },  // 73 s
		{ 0x04, 0x3f, 0x44, 0x40, 0x20 },  // 74 t
		{ 0x3c, 0x40, 0x40, 0x20, 0x7c },  // 75 u
		{ 0x1c, 0x20, 0x40, 0x20, 0x1c },  // 76 v
		{ 0x3c, 0x40, 0x30, 0x40, 0x3c },  // 77 w
		{ 0x44, 0x28, 0x10, 0x28, 0x44 },  // 78 x
		{ 0x0c, 0x50, 0x50, 0x50, 0x3c },  // 79 y
		{ 0x44, 0x64, 0x54, 0x4c, 0x44 },  // 7a z
		{ 0x00, 0x08, 0x36, 0x41, 0x00 },  // 7b {
		{ 0x00, 0x00, 0x7f, 0x00, 0x00 },  // 7c |
		{ 0x00, 0x41, 0x36, 0x08, 0x00 },  // 7d }
		{ 0x10, 0x08, 0x08, 0x10, 0x08 },  // 7e ~
		};

const unsigned char KLAsmall[] =
{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x20, 0x10, 0x08, 0x08, 0x0C, 0x1C,
		0xFC, 0xF8, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0xFF, 0x7F, 0x70, 0xF8, 0xFC,
		0x8E, 0x07, 0x03, 0x01, 0x00, 0xFC, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0xC0,
		0xE0, 0xF8, 0x3E, 0x0F, 0x0F, 0xFF, 0xFE, 0xC0, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x03, 0xC3, 0xFF, 0xFF, 0x0F, 0x03, 0xE3, 0xF0,
		0x78, 0x58, 0x48, 0x58, 0x70, 0x60, 0x00, 0xC0, 0xF8, 0xF8, 0x10, 0x10,
		0x18, 0xF8, 0xF0, 0x00, 0x80, 0xE0, 0xF0, 0x38, 0x18, 0x18, 0x18, 0x00,
		0xE0, 0xF0, 0x38, 0x18, 0x18, 0x38, 0xF8, 0xF0, 0x00, 0x00, 0xF0, 0xF8,
		0x78, 0x30, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07,
		0x00, 0x00, 0x00, 0x03, 0x07, 0x07, 0x04, 0x00, 0x06, 0x07, 0x07, 0x07,
		0x07, 0x07, 0x07, 0x07, 0x03, 0x00, 0x00, 0xFC, 0xFF, 0x8F, 0x07, 0x07,
		0x00, 0x80, 0xC0, 0x60, 0x30, 0x18, 0x0C, 0x00, 0x00, 0x07, 0x07, 0x03,
		0x00, 0x00, 0x03, 0x07, 0x06, 0x06, 0x06, 0x06, 0x02, 0x00, 0x00, 0x07,
		0x07, 0x00, 0x00, 0x00, 0x06, 0x07, 0x03, 0x00, 0x01, 0x03, 0x07, 0x06,
		0x06, 0x06, 0x00, 0x00, 0x03, 0x07, 0x07, 0x06, 0x06, 0x07, 0x03, 0x01,
		0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
		0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00 };

/*
 * Selecting arrow and status symbols
 */
const unsigned char arrow8x8[8] =
{ 0x81, 0x66, 0x7E, 0x3C, 0x3C, 0x18, 0x18, 0x00, };

const unsigned char CAN[8] =
{ 0x3C, 0x7E, 0xFF, 0xC3, 0x81, 0x81, 0x42, 0x24, };

const unsigned char thingspeak[8] =
{ 0x01, 0x01, 0x1F, 0x01, 0xCD, 0x94, 0xA4, 0xCC, };

const unsigned char LAN[8] =
{ 0x0B, 0x0F, 0xEB, 0xF8, 0xF8, 0xEB, 0x0F, 0x0B, };

/*
 * SDCS status symbol
 */
const unsigned char SDCSunreachable[] =
{ 0x3C, 0x42, 0xA1, 0x91, 0x89, 0x85, 0x42, 0x3C, };

const unsigned char SDCSOK[] =
{ 0x18, 0x30, 0x60, 0xE0, 0x70, 0x18, 0x04, 0x02, };

void drawSDCSOK()
{
	draw(SDCSOK, 8, 8);
}

void drawSDCSunreachable()
{
	draw(SDCSunreachable, 8, 8);
}

void drawArrow()
{
	draw(arrow8x8, 8, 8);
}

void drawCAN()
{
	//setCursor(88, 7);
	setCursor(88, 3);
	draw(CAN, 8, 8);
}

void deleteCAN()
{
	OLEDclear(88, 24, 8, 8);
}

void drawLAN()
{
	//setCursor(104, 7);
	setCursor(104, 3);
	draw(LAN, 8, 8);
}

void deleteLAN()
{
	OLEDclear(104, 24, 8, 8);
}

void drawTS()
{
	//setCursor(120, 7);
	setCursor(120, 3);
	draw(thingspeak, 8, 8);
}

void deleteTS()
{
	OLEDclear(120, 24, 8, 8);
}

void WriteCommand(unsigned char ins)
{
	if (OLEDbroken)
		return;
	addToI2CBuffer(0x00);
	addToI2CBuffer(ins);
	sendI2CBuffer();
}

void ShowLoadingScreen()
{
	OLEDclear(0, 0, 128, 64);
	draw(KLAsmall, 88, 32);
	setCursor(0, 4);
	OLEDprintln("IoT warehouse");
	OLEDprintln("monitoring system");
}

void OLEDsinglePrint(char *theString)
{
	OLEDclear(0, 0, 128, 56);
	OLEDprintwrap(theString);
}

void OLEDreset()
{
	unsigned long dummy;
	uint8_t i, j, k;
	OLEDbroken = 0;

	GPIOPinTypeGPIOOutput(GPIO_PORTL_BASE, GPIO_PIN_2);
	GPIOPinWrite(GPIO_PORTL_BASE, GPIO_PIN_2, GPIO_PIN_2);
	timeOutSet(&dummy);
	while (!timeIsOut(dummy, 1))
		;
	GPIOPinWrite(GPIO_PORTL_BASE, GPIO_PIN_2, 0);
	timeOutSet(&dummy);
	while (!timeIsOut(dummy, 1))
		;
	GPIOPinWrite(GPIO_PORTL_BASE, GPIO_PIN_2, GPIO_PIN_2);

	//i2cInit();
	WriteCommand(SSD1306_DISPLAYOFF);                    // 0xAE
	WriteCommand(SSD1306_SETDISPLAYCLOCKDIV);            // 0xD5
	WriteCommand(0x80);                              // the suggested ratio 0x80
	WriteCommand(SSD1306_SETMULTIPLEX);                  // 0xA8
	WriteCommand(0x1F);
	WriteCommand(SSD1306_SETDISPLAYOFFSET);              // 0xD3
	WriteCommand(0x0);                                   // no offset
	WriteCommand(SSD1306_SETSTARTLINE | 0x0);            // line #0
	WriteCommand(SSD1306_CHARGEPUMP);                    // 0x8D
	{
		WriteCommand(0x14);
	}
	WriteCommand(SSD1306_MEMORYMODE);                    // 0x20
	WriteCommand(0x00);                                  // 0x0 act like ks0108
	WriteCommand(SSD1306_SEGREMAP | 0x1);
	WriteCommand(SSD1306_COMSCANDEC);
	WriteCommand(SSD1306_SETCOMPINS);                    // 0xDA
	WriteCommand(0x02);
	WriteCommand(SSD1306_SETCONTRAST);                   // 0x81
	WriteCommand(0x8F);
	WriteCommand(SSD1306_SETPRECHARGE);                  // 0xd9
	{
		WriteCommand(0xF1);
	}
	WriteCommand(SSD1306_SETVCOMDETECT);                 // 0xDB
	WriteCommand(0x40);
	WriteCommand(SSD1306_DISPLAYALLON_RESUME);           // 0xA4
	WriteCommand(SSD1306_NORMALDISPLAY);                 // 0xA6

	WriteCommand(SSD1306_DISPLAYON);                 //--turn on oled panel

	WriteCommand(SSD1306_SETLOWCOLUMN | 0x0);  // low col = 0
	WriteCommand(SSD1306_SETHIGHCOLUMN | 0x0);  // hi col = 0
	WriteCommand(SSD1306_SETSTARTLINE | 0x0); // line #0

	for (i = 0; i < SSD1306_LCDHEIGHT / 8; i++)
	{
		// send a bunch of data in one xmission
		WriteCommand(0xB0 + i); //set page address
		WriteCommand(0); //set lower column address
		WriteCommand(0x10); //set higher column address

		for (j = 0; j < 8; j++)
		{
			//Wire.write(0x40);
			addToI2CBuffer(0x40);
			for (k = 0; k < SSD1306_LCDWIDTH / 8; k++)
			{
				//Wire.write(0);
				addToI2CBuffer(0);
			}
			sendI2CBuffer();
		}
	}
}

void OLEDbegin()
{
	unsigned long dummy;
	uint8_t i, j, k;
	OLEDbroken = 0;

	GPIOPinTypeGPIOOutput(GPIO_PORTL_BASE, GPIO_PIN_2);
	GPIOPinWrite(GPIO_PORTL_BASE, GPIO_PIN_2, GPIO_PIN_2);
	timeOutSet(&dummy);
	while (!timeIsOut(dummy, 1))
		;
	GPIOPinWrite(GPIO_PORTL_BASE, GPIO_PIN_2, 0);
	timeOutSet(&dummy);
	while (!timeIsOut(dummy, 1))
		;
	GPIOPinWrite(GPIO_PORTL_BASE, GPIO_PIN_2, GPIO_PIN_2);

	i2cInit();
	WriteCommand(SSD1306_DISPLAYOFF);                    // 0xAE
	WriteCommand(SSD1306_SETDISPLAYCLOCKDIV);            // 0xD5
	WriteCommand(0x80);                              // the suggested ratio 0x80
	WriteCommand(SSD1306_SETMULTIPLEX);                  // 0xA8
	WriteCommand(0x1F);
	WriteCommand(SSD1306_SETDISPLAYOFFSET);              // 0xD3
	WriteCommand(0x0);                                   // no offset
	WriteCommand(SSD1306_SETSTARTLINE | 0x0);            // line #0
	WriteCommand(SSD1306_CHARGEPUMP);                    // 0x8D
	{
		WriteCommand(0x14);
	}
	WriteCommand(SSD1306_MEMORYMODE);                    // 0x20
	WriteCommand(0x00);                                  // 0x0 act like ks0108
	WriteCommand(SSD1306_SEGREMAP | 0x1);
	WriteCommand(SSD1306_COMSCANDEC);
	WriteCommand(SSD1306_SETCOMPINS);                    // 0xDA
	WriteCommand(0x02);
	WriteCommand(SSD1306_SETCONTRAST);                   // 0x81
	WriteCommand(0x8F);
	WriteCommand(SSD1306_SETPRECHARGE);                  // 0xd9
	{
		WriteCommand(0xF1);
	}
	WriteCommand(SSD1306_SETVCOMDETECT);                 // 0xDB
	WriteCommand(0x40);
	WriteCommand(SSD1306_DISPLAYALLON_RESUME);           // 0xA4
	WriteCommand(SSD1306_NORMALDISPLAY);                 // 0xA6

	WriteCommand(SSD1306_DISPLAYON);                 //--turn on oled panel

	WriteCommand(SSD1306_SETLOWCOLUMN | 0x0);  // low col = 0
	WriteCommand(SSD1306_SETHIGHCOLUMN | 0x0);  // hi col = 0
	WriteCommand(SSD1306_SETSTARTLINE | 0x0); // line #0

	for (i = 0; i < SSD1306_LCDHEIGHT / 8; i++)
	{
		// send a bunch of data in one xmission
		WriteCommand(0xB0 + i); //set page address
		WriteCommand(0); //set lower column address
		WriteCommand(0x10); //set higher column address

		for (j = 0; j < 8; j++)
		{
			//Wire.write(0x40);
			addToI2CBuffer(0x40);
			for (k = 0; k < SSD1306_LCDWIDTH / 8; k++)
			{
				//Wire.write(0);
				addToI2CBuffer(0);
			}
			sendI2CBuffer();
		}
	}
}

void OLEDclear(uint8_t x, uint8_t y, uint8_t width, uint8_t height)
{
	uint8_t i = 0;
	uint8_t j = 0;
	uint8_t k = 0;

	if (OLEDbroken)
		return;

	WriteCommand(SSD1306_SETLOWCOLUMN | 0x0);  // low col = 0
	WriteCommand(SSD1306_SETHIGHCOLUMN | 0x0);  // hi col = 0
	WriteCommand(SSD1306_SETSTARTLINE | 0x0); // line #0

	height >>= 3;
	width >>= 3;
	y >>= 3;

	for (i = 0; i < height; i++)
	{
		WriteCommand(0xB0 + i + y); //set page address
		WriteCommand((x + 2) & 0xf); //set lower column address
		WriteCommand(0x10 | (x >> 4)); //set higher column address

		for (j = 0; j < 8; j++)
		{
			addToI2CBuffer(0x40);
			for (k = 0; k < width; k++)
			{
				addToI2CBuffer(0);
			}
			sendI2CBuffer();
		}
	}
	setCursor(0, 0);
}

uint8_t write(uint8_t c)
{
	uint8_t d = 0;
	uint8_t i = 0;

	if (OLEDbroken)
		return 0;

	if (c == '\n')
	{
		setCursor(0, m_row + 1);
		return 1;
	}
	else if (c == '\r')
	{
		m_col = 0;
		return 1;
	}

	addToI2CBuffer(0x40);
	if (c > 0x20 && c < 0x7f)
	{
		c -= 0x21;
		for (i = 0; i < 5; i++)
		{
			d = font5x8[c][i];
			addToI2CBuffer(d);
		}
		addToI2CBuffer(0);
	}
	else
	{
		for (i = 6; i > 0; i--)
		{
			addToI2CBuffer(0);
		}
	}
	sendI2CBuffer();

	m_col += 6;
	if (m_col >= 128)
	{
		m_col = 0;
		m_row++;
	}

	return 1;
}

void writeDigit(uint8_t n)
{
	uint8_t i;

	if (OLEDbroken)
		return;

	addToI2CBuffer(0x40);
	if (n <= 9)
	{
		n += '0' - 0x21;
		for (i = 0; i < 5; i++)
		{
			//Wire.write(pgm_read_byte(&font5x8[n][i]));
			addToI2CBuffer(font5x8[n][i]);
		}
		//Wire.write(0);
		addToI2CBuffer(0);
	}
	else
	{
		for (i = 0; i < 6; i++)
		{
			addToI2CBuffer(0);
		}
	}
	sendI2CBuffer();
	m_col += 6;
}

void OLEDprint(char *theString)
{
	unsigned long i = 0;

	if (OLEDbroken)
		return;

	while (*(theString + i) != 0)
	{
		if ((*(theString + i) >= 0x21) && (*(theString + i) <= 0x7e))
		{
			write(*(theString + i));
		}
		else
		{
			writeDigit(*(theString + i) - 0x31);
		}
		i++;
	}
}

void OLEDprintwrap(char *theString)
{
	unsigned long i = 0;

	if (OLEDbroken)
		return;

	while (*(theString + i) != 0)
	{
		if ((i > 0) && (i % 20 == 0))
		{
			write('\n');
		}
		if ((*(theString + i) >= 0x21) && (*(theString + i) <= 0x7e))
		{
			write(*(theString + i));
		}
		else
		{
			writeDigit(*(theString + i) - 0x31);
		}
		i++;
	}
}

void OLEDprintln(char *theString)
{
	unsigned long i = 0;

	if (OLEDbroken)
		return;

	while (*(theString + i) != 0)
	{
		if ((*(theString + i) >= 0x21) && (*(theString + i) <= 0x7e))
		{
			write(*(theString + i));
		}
		else
		{
			writeDigit(*(theString + i) - 0x31);
		}
		i++;
	}
	write('\n');
}

void setCursor(uint8_t x, uint8_t y)
{
	if (OLEDbroken)
		return;

	m_col = x + 2;
	m_row = y;
	WriteCommand(0xb0 + m_row);
	WriteCommand(m_col & 0xf); //set lower column address
	WriteCommand(0x10 | (m_col >> 4)); //set higher column address
}

void draw(const uint8_t* buffer, uint8_t width, uint8_t height)
{
	uint8_t i = 0;
	uint8_t j = 0;
	uint8_t k = 0;
	const uint8_t *p = buffer;

	if (OLEDbroken)
		return;

	WriteCommand(SSD1306_SETLOWCOLUMN | 0x0);  // low col = 0
	WriteCommand(SSD1306_SETHIGHCOLUMN | 0x0);  // hi col = 0
	WriteCommand(SSD1306_SETSTARTLINE | 0x0); // line #0

	height >>= 3;
	width >>= 3;
	for (i = 0; i < height; i++)
	{
		// send a bunch of data in one xmission
		WriteCommand(0xB0 + i + m_row); //set page address
		WriteCommand(m_col & 0xf); //set lower column address
		WriteCommand(0x10 | (m_col >> 4)); //set higher column address

		for (j = 0; j < 8; j++)
		{
			addToI2CBuffer(0x40);
			for (k = 0; k < width; k++, p++)
			{
				addToI2CBuffer(*p);
			}
			sendI2CBuffer();
		}
	}
	m_col += width;
}
